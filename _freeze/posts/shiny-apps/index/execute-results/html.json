{
  "hash": "bc3b6ae6a9d336a614120a5eccc38766",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Shiny apps in R\"\nauthor: \"Sven Nelson\"\ndate: \"2024-06-25\"\ncategories: [shiny, modules]\nimage: \"monarch.png\"\nformat:\n  html:\n    code-overflow: wrap\n---\n\n\n## Brief introduction to Shiny\n\n-   Parts of a Shiny app\n-   When to use a Shiny app\n-   When not to use a Shiny app\n    -   Alternatives: Rmarkdown/Quarto, Jupyter notebooks can do R, R script and output figures\n\n## Step-by-step script to Shiny app\n\n-   Walk through the process of starting with an R script and then ending with a Shiny app\n\n### Selecting a dataset\n\nLet's use a fun dataset. This post produced the GIF below in R showing monarch butterfly migrations.\n\n-   [https://medium.com/\\@jakeamahr/using-rgbif-to-visualize-annual-monarch-butterfly-migrations-f34a335b77f1](https://medium.com/@jakeamahr/using-rgbif-to-visualize-annual-monarch-butterfly-migrations-f34a335b77f1){.uri}\n\n    [![Monarch Butterfly Migrations](https://miro.medium.com/v2/resize:fit:4800/format:webp/1*pZFQlxz6y6qhtZXdnSbqIg.gif)](https://medium.com/@jakeamahr/using-rgbif-to-visualize-annual-monarch-butterfly-migrations-f34a335b77f1)\n\n-   We won't replicate this (you can follow the link if you would like to do that), but we can use the same data source.\n\nThe Global Biodiversity Information Facility (GBIF) is a free an open access database with a lot of information that can be mined about all different species of organisms.\n\n-   <https://www.gbif.org/>\n\n-   There is an R package that makes it easy to access this data:\n\n    -   <https://www.gbif.org/tool/81747/rgbif>\n\n    -   <https://docs.ropensci.org/rgbif/index.html>\n\n        -   This page has a lot of examples and information on how to use the package\n\n    -   You can make a free account and download larger datasets, but we will just use the `occ_count()` function that doesn't require an account.\n\n        -   If you do create an account at gbid.org, you can set it up for use in R using the following link:\n\n            -   <https://docs.ropensci.org/rgbif/articles/gbif_credentials.html>\n\n        -   Then you can use the function `occ_download()` which will query the full database\n\n### Start with an R script\n\n-   Easier to work out the kinks for a single example\n\n-   Can run line-by-line to test the outputs at each step and correct any issues\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgbif)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get monarch taxonKey\nmonarch <- name_backbone(\"Danaus plexippus\")$usageKey\n\n# remember to set up your GBIF credentials to use occ_download()\n# test <- rgbif::occ_download(pred(\"taxonKey\", monarch),format = \"SIMPLE_CSV\")\n\n# Evansville and surrounding area\nwkt <- \"POLYGON((-88.54 38.54, -88.54 37.80, -86.74 37.80, -86.74 38.54, -88.54 38.54))\"\nEV_monarchs <- occ_count(facet=c(\"month\"), taxonKey=monarch, geometry=wkt)\n\nlibrary(tidyverse)\n# Make month columns into integers\nEV_monarchs$month <- as.numeric(EV_monarchs$month)\n# Fill in missing months with 0 values\nfor (i in 1:12) {\n  if (!(i %in% EV_monarchs$month)) {\n    EV_monarchs <- add_row(EV_monarchs, month = i, count = 0)\n  }\n}\n\n# Order rows by month\nEV_monarchs <- arrange(EV_monarchs, month)\n\n# Make column with text month names\nEV_monarchs <- mutate(EV_monarchs, Month = month.abb[month])\n\n# Make Month column factors\nEV_monarchs$Month <- factor(EV_monarchs$Month, levels = EV_monarchs$Month)\n\n# Plot the data as a barplot with occurrences for each month\nlibrary(ggplot2)\nggplot(EV_monarchs, aes(x = Month, y = count)) + # , fill = count\n  geom_bar(stat=\"identity\", color=\"black\", fill = \"cyan\") + \n  xlab(\"Time of year\") + \n  ylab(\"Occurrences\") + \n  ggtitle(\"Monarchs in Evansville\") +\n  # scale_fill_gradient(low=\"cyan\", high=\"cyan\") +\n  theme_bw() + \n  theme(panel.border = element_blank(), panel.grid.major = element_blank(),\npanel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\")) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=384}\n:::\n:::\n\n\n### Next, convert this script into a function\n\n-   Determine what the parameters will be (variables that you will change)\n\n    -   It would be nice to see the same graphs for monarch butterflies from other **locations**\n\n    -   It would be nice to see the same graphs for different **species**\n\n-   Change names are are specific like \"EV_monarchs\" to something not specific to the location (EV) or species (monarchs) so that the code reads well regardless of what these 2 variables are set to.\n\n-   For functions, I generally change `library()` to `require()`\n\n    -   The only difference is that require won't re-load a package if it is already loaded\n\n    -   This is optional, since `library()` will still work\n\n    -   Remove duplicates so you only load each library once (unless necessary to reload in a different order)\n\n    -   For functions like `filter()` which exist in multiple packages, always call with `::` specifying the package\n\n        -   Always use `dplyr::filter()` never `filter()`\n\n-   Improve your comments here as you go to specify what each step is (what each line is doing)\n\n-   If your output is a plot, instead of just plotting, return the plot object at the end\n\n    -   If you just let it return, it will plot, but you can also save the output to a variable and modify settings later. *(In this case, we will do this to change the bar colors for each duplicate plot.)*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_sightings <- function(species = \"Danaus plexippus\", location = wkt, title = \"Monarchs in Evansville\") {\n  require(rgbif)\n  require(tidyverse)\n  \n  # Get species taxonKey\n  spec_id <- name_backbone(species)$usageKey\n  \n  # Get data from rgbif for the passed species at the passed location\n  sightings <- occ_count(facet=c(\"month\"), taxonKey=spec_id, geometry=location)\n  \n  library(tidyverse)\n  # Make month columns into integers\n  sightings$month <- as.numeric(sightings$month)\n  # Fill in missing months with 0 values\n  for (i in 1:12) {\n    if (!(i %in% sightings$month)) {\n      sightings <- add_row(sightings, month = i, count = 0)\n    }\n  }\n  \n  # Order rows by month\n  sightings <- arrange(sightings, month)\n  \n  # Make column with text month names\n  sightings <- mutate(sightings, Month = month.abb[month])\n  \n  # Make Month column factors\n  sightings$Month <- factor(sightings$Month, levels = sightings$Month)\n  \n  # Plot the data as a barplot with occurrences for each month\n  plt <- ggplot(sightings, aes(x = Month, y = count)) + # , fill = count\n    geom_bar(stat=\"identity\", color=\"black\", fill = \"cyan\") + \n    xlab(\"Time of year\") + \n    ylab(\"Occurrences\") + \n    ggtitle(title) +\n    theme_bw() + \n    theme(panel.border = element_blank(), panel.grid.major = element_blank(),\n  panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\")) \n  \n  return(plt)\n}\n```\n:::\n\n\nNow to run it we can do:\n\n-   Note that output plot size is set here for Quarto with `{r fig.width=4, fig.height=2}` for the code block\n\n-   We will have to set this in our Shiny app in a different way later\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Monarch butterfly (Danaus plexippus)\nplot_sightings(species = \"Danaus plexippus\", location = wkt, \"Monarchs in Evansville\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=384}\n:::\n\n```{.r .cell-code}\n# Northern Cardinal (Cardinalis cardinalis)\nplot_sightings(species = \"Cardinalis cardinalis\", location = wkt, \"Cardinals in Evansville\") + \n  geom_bar(stat=\"identity\", color=\"black\", fill = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=384}\n:::\n\n```{.r .cell-code}\n# Ruby Throated Hummingbird (Archilochus colubris)\nplot_sightings(species = \"Archilochus colubris\", location = wkt, \"Hummingbirds in Evansville\") + \n  geom_bar(stat=\"identity\", color=\"black\", fill = \"pink\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-3.png){width=384}\n:::\n\n```{.r .cell-code}\n# White-Throated Sparrow (Zonotrichia albicollis)\nplot_sightings(species = \"Zonotrichia albicollis\", location = wkt, \"Sparrows in Evansville\") + \n  geom_bar(stat=\"identity\", color=\"black\", fill = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-4.png){width=384}\n:::\n:::\n\n\n### Helper functions\n\nSometimes a variable is not simply a single word, number, or boolean. In this case, you may need to define additional functions to create the variable given a simpler input\n\n-   location is set with:\n\n``` r\n# Evansville and surrounding area\nwkt <- \"POLYGON((-88.54 38.54, -88.54 37.80, -86.74 37.80, -86.74 38.54, -88.54 38.54))\"\n```\n\n-   These are the four corners of a rectangle as Latitude and Longitude in counterclockwise direction around the rectangle (the direction is important, clockwise will exclude the area inside)\n\n-   I defined this manually using the tool here and Apple/Google Maps\n\n    -   <https://www.gbif.org/occurrence/search?basis_of_record=HUMAN_OBSERVATION&has_coordinate=true&has_geospatial_issue=false&taxon_key=5133088&year=1990,2024&geometry=POLYGON((-88.54438%2037.48459,-86.74461%2037.48459,-86.74461%2038.86468,-88.54438%2038.86468,-88.54438%2037.48459))>\n\n-   To simplify this, it would be nice to have a function that takes either a single Latitude and Longitude or a city name and generates the wkt output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidygeocoder)\n\n# Create table of possible cities to check\nlocs <- tibble::tribble(\n~name,            ~address,\n\"Evansville\",     \"Evansville, IN\",\n\"West Lafayette\", \"West Lafayette, IN 47907\", \n\"Davis\",          \"Davis, CA\",\n\"Seattle\",        \"Seattle, WA\",\n\"New Jersey\",     \"New Jersey, NY\",\n\"Miami\",          \"Miami, FL\",\n\"LA\",             \"Los Angelos, CA\"\n)\n\n# Get latitude and longitude\nlocs <- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPassing 7 addresses to the Nominatim single address geocoder\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nQuery completed in: 7.1 seconds\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create function to generate string with 4 corners for POLYGON call\ngenerate_polygon <- function(lat, long, d_lg=0.9, d_lt=0.37) {\n  # \"POLYGON((-88.54 38.54, -88.54 37.80, -86.74 37.80, -86.74 38.54, -88.54 38.54))\"\n  p = paste0(\"POLYGON((\",\n             long-d_lg, \" \", lat+d_lt, \", \",\n             long-d_lg,\" \", lat-d_lt, \", \",\n             long+d_lg,\" \", lat-d_lt, \", \",\n             long+d_lg,\" \", lat+d_lt, \", \",\n             long-d_lg, \" \", lat+d_lt,\n             \"))\")\n  return(p)\n}\n\n# Test function with anu location\nanu <- generate_polygon(locs$latitude[1], locs$longitude[1])\n\n# Monarch butterfly (Danaus plexippus) at anu\nplot_sightings(species = \"Danaus plexippus\", location = anu)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=384}\n:::\n\n```{.r .cell-code}\n# Populate a column in the data frame with the POLYGON call for each location\nlocs2 <- mutate(locs, polygon = generate_polygon(locs$latitude, locs$longitude))\n## THIS DOESN'T WORK BECAUSE PASTE IS NOT VECTORIZED\n\n# Create function to generate string with 4 corners for POLYGON call\ngenerate_polygon <- function(lat, long, d_lg=0.9, d_lt=0.37) {\n  # Paste is not vectorize, use sprintf instead (limit decimals to 4 places)\n  p = sprintf(\"POLYGON((%.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f))\", \n              long-d_lg, lat+d_lt, \n              long-d_lg, lat-d_lt,\n              long+d_lg, lat-d_lt,\n              long+d_lg, lat+d_lt,\n              long-d_lg, lat+d_lt\n              )\n  return(p)\n}\n\n# Populate a column in the data frame with the POLYGON call for each location\nlocs <- mutate(locs, polygon = generate_polygon(locs$latitude, locs$longitude))\n## THIS WORKS NOW\n\n# Plot all locations\nfor (i in 1:nrow(locs)) {\n  plt <- plot_sightings(species = \"Danaus plexippus\", location = locs$polygon[i], \n                        paste0(\"Monarchs in \", locs$name[i]))\n  print(plt)\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-2.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-3.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-4.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-5.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-6.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-7.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-8.png){width=384}\n:::\n:::\n\n\n### Use `manipulate()` in RStudio for quick and simple interactive plotting\n\n-   The `manipulate` package only works in RStudio, but it gives you a very quick and simple way to get drop downs and other selectors like you would do in a Shiny app without a lot of coding.\n\n-   You can use these sorts of controls:\n\n    -   Sliders\n\n    -   Dropdown pickers\n\n    -   Checkboxes\n\n    -   And combinations of the above\n\n    ``` r\n    # Very simple example to make sure manipulate is working\n    library(manipulate)\n    manipulate(plot(1:X), X = slider(1, 10))\n    ```\n\n-   More info here:\n\n    -   <https://support.posit.co/hc/en-us/articles/200551906-Interactive-Plotting-with-Manipulate-in-the-RStudio-IDE>\n\n-   A simple example using our dataset and function:\n\n``` r\nlibrary(manipulate)\n\nmanipulate(\n  plot_sightings(species = Species, location = locs$polygon[1], \n                        paste0(\"Monarchs in \", locs$name[1])),\n  Species = picker(\n    \"Monarch Butterfly\" = \"Danaus plexippus\", \n    \"Northern Cardinal\" = \"Cardinalis cardinalis\", \n    \"Ruby Throated Hummingbird\" = \"Archilochus colubris\",\n    \"White-Throated Sparrow\" = \"Zonotrichia albicollis\"),\n  Location = picker(\n    \"Evansville\" = \"Evansville, IN\",\n    \"West Lafayette\" = \"West Lafayette, IN 47907\", \n    \"Davis\" = \"Davis, CA\",\n    \"Seattle\" = \"Seattle, WA\",\n    \"New Jersey\" = \"New Jersey, NY\",\n    \"Miami\" = \"Miami, FL\",\n    \"LA\" = \"Los Angelos, CA\"\n  )\n)\n```\n\n-   You can't view manipulate in the browser, so I'll paste a screenshot here and show a live demo during the tutorial:\n\n    ![](manipulate_example.png)\n\n-   Another similar package that I haven't tried based on `manipulate` is `manipulateWidget`\n\n    -   <https://cran.r-project.org/web/packages/manipulateWidget/vignettes/manipulateWidgets.html>\n\n### Now on to a Shiny app\n\n-   A Shiny app gives you more control over the look and feel, more options as far as the ways to interact or display your data, and can run in a web browser locally or across the internet without requiring the viewer to have R or your code running on their system.\n\nHelper function add_polygon_col.R:\n\n``` r\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Function for generating a polygon with 4 corners for RGBIF                  #\n###############################################################################\n\nrequire(tidygeocoder)\n\n# Function to return df with polygon column\nadd_polygon_col <- function(df) {\n  # Create function to generate string with 4 corners for POLYGON call\n  generate_polygon <- function(lat, long, d_lg=0.9, d_lt=0.37) {\n    # Paste is not vectorize, use sprintf instead (limit decimals to 4 places)\n    p = sprintf(\"POLYGON((%.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f))\", \n                long-d_lg, lat+d_lt, \n                long-d_lg, lat-d_lt,\n                long+d_lg, lat-d_lt,\n                long+d_lg, lat+d_lt,\n                long-d_lg, lat+d_lt\n    )\n    return(p)\n  }\n  # Populate a column in the data frame with the POLYGON call for each location\n  df <- mutate(df, polygon = generate_polygon(df$latitude, df$longitude))\n  return(df)\n}\n```\n\n**app.R:**\n\n``` r\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app for plotting species occurrence from GBIF.                        #\n###############################################################################\n\n#### Imports ####\nrequire(shiny)\nrequire(tidygeocoder)\nrequire(memoise)\n\nsource(\"../R/plot_sightings.R\")\nsource(\"../R/add_polygon_col.R\")\n\n#### Setup ####\n# Set up a dataframe to use connecting names with species\nspecs <- tibble::tribble(\n  ~name,                        ~species,                 ~short_name,    ~clr,\n  \"Monarch Butterfly\",          \"Danaus plexippus\",       \"Monarch\",      \"cyan\",\n  \"Northern Cardinal\",          \"Cardinalis cardinalis\",  \"Cardinal\",     \"red\",\n  \"Ruby Throated Hummingbird\",  \"Archilochus colubris\",   \"Hummingbird\",  \"pink\",\n  \"White-Throated Sparrow\",     \"Zonotrichia albicollis\", \"Sparrow\",      \"yellow\"\n)\n\n# Create the table of possible cities to check\nlocs <- tibble::tribble(\n  ~name,            ~address,\n  \"Evansville\",     \"Evansville, IN\",\n  \"West Lafayette\", \"West Lafayette, IN 47907\", \n  \"Davis\",          \"Davis, CA\",\n  \"Seattle\",        \"Seattle, WA\",\n  \"New Jersey\",     \"New Jersey, NY\",\n  \"Miami\",          \"Miami, FL\",\n  \"LA\",             \"Los Angelos, CA\"\n)\n# Variable to keep track of whether data needs to be reloaded\nreload_data <- TRUE\nif (file.exists(\"locs.rds\")) {\n  locs2 <- readRDS(\"locs.rds\")\n  \n  if (dplyr::all_equal(locs, locs2[,1:2]) & ncol(locs2) == 5) {\n    locs <- locs2\n    reload_data <- FALSE\n  }\n} \n\nif (reload_data) {\n  # Get latitude and longitude\n  locs <- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n  \n  # Populate a column in the data frame with the POLYGON call for each location\n  locs <- add_polygon_col(locs)\n  saveRDS(locs, file = \"locs.rds\")\n}\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nui <- fluidPage(\n\n  # Application title\n  titlePanel(\"Organism migration tracking\"),\n\n  # Sidebar with a slider input for number of bins \n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"spec_pick\", \"Organism\", choices = specs$name),\n      selectInput(\"loc_pick\", \"Location\", choices = locs$name)\n    ),\n\n    # Show a plot of the generated distribution\n    mainPanel(\n      plotOutput(\"sightingsPlot\", width = 400, height = 200) # Set size here\n    )\n  )\n)\n\n#### Server function ####\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n\n  output$sightingsPlot <- renderPlot({\n    # generate bins based on input$bins from ui.R\n    sp_nm <- input$spec_pick\n    lc_nm <- input$loc_pick\n    sp <- specs[specs$name == sp_nm,]$species\n    sp_col <- specs[specs$name == sp_nm,]$clr\n    lc <- locs[locs$name == lc_nm,]$polygon\n    \n    plot_sightings(species = sp, location = lc, paste0(sp_nm, \" in \", lc_nm)) + \n      geom_bar(stat=\"identity\", color=\"black\", fill = sp_col)\n  })\n}\n\n#### Run app ####\nshinyApp(ui = ui, server = server)\n```\n\n### Shiny Modules\n\n-   Convert to module\n\n    -   <https://shiny.posit.co/r/articles/improve/modules/>\n\n    -   We will end up with a `.R` file with the module code, which we can run in a `app.R` shiny app.\n\nThe file **sightingsModule.R** below:\n\n``` r\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app module for plotting species occurrence from GBIF.                 #\n###############################################################################\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nsightingsInput <- function(id, label = \"Sightings\", specs, locs, sel = \"Monarch Butterfly\") {\n  ns <- NS(id)\n  tagList(\n    h4(label),\n    selectInput(ns(\"spec_pick\"), \"Organism\", choices = specs$name, selected = sel),\n    selectInput(ns(\"loc_pick\"), \"Location\", choices = locs$name)\n  )\n}\n\nsightingsOutput <- function(id, label = \"Sightings\") {\n  ns <- NS(id)\n  tagList(\n    plotOutput(ns(\"sightingsPlot\"), width = 400, height = 200)\n  )\n}\n\n#### Server function ####\n# Define server logic required to draw a histogram\nsightingsServer <- function(id, specs, locs) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      output$sightingsPlot <- renderPlot({\n        # generate bins based on input$bins from ui.R\n        sp_nm <- input$spec_pick\n        lc_nm <- input$loc_pick\n        sp <- specs[specs$name == sp_nm,]$species\n        sp_col <- specs[specs$name == sp_nm,]$clr\n        lc <- locs[locs$name == lc_nm,]$polygon\n        \n        plot_sightings(species = sp, location = lc, paste0(sp_nm, \" in \", lc_nm)) + \n          geom_bar(stat=\"identity\", color=\"black\", fill = sp_col)\n      })\n    }\n  )\n}\n```\n\nThe file **app.R** with the shiny app using a single instance of the same module.\n\n``` r\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app for plotting species occurrence from GBIF.                        #\n###############################################################################\n\n#### Imports ####\nrequire(shiny)\nrequire(tidygeocoder)\n\nsource(\"../R/plot_sightings.R\")\nsource(\"../R/add_polygon_col.R\")\nsource(\"../R/sightingsModule.R\")\n\n#### Setup ####\n# Set up a dataframe to use connecting names with species\nspecs <- tibble::tribble(\n  ~name,                        ~species,                 ~short_name,    ~clr,\n  \"Monarch Butterfly\",          \"Danaus plexippus\",       \"Monarch\",      \"cyan\",\n  \"Northern Cardinal\",          \"Cardinalis cardinalis\",  \"Cardinal\",     \"red\",\n  \"Ruby Throated Hummingbird\",  \"Archilochus colubris\",   \"Hummingbird\",  \"pink\",\n  \"White-Throated Sparrow\",     \"Zonotrichia albicollis\", \"Sparrow\",      \"yellow\"\n)\n\n# Create the table of possible cities to check\nlocs <- tibble::tribble(\n  ~name,            ~address,\n  \"Evansville\",     \"Evansville, IN\",\n  \"West Lafayette\", \"West Lafayette, IN 47907\", \n  \"Davis\",          \"Davis, CA\",\n  \"Seattle\",        \"Seattle, WA\",\n  \"New Jersey\",     \"New Jersey, NY\",\n  \"Miami\",          \"Miami, FL\",\n  \"LA\",             \"Los Angelos, CA\"\n)\n# Variable to keep track of whether data needs to be reloaded\nreload_data <- TRUE\nif (file.exists(\"locs.rds\")) {\n  locs2 <- readRDS(\"locs.rds\")\n  \n  if (dplyr::all_equal(locs, locs2[,1:2]) & ncol(locs2) == 5) {\n    locs <- locs2\n    reload_data <- FALSE\n  }\n} \n\nif (reload_data) {\n  # Get latitude and longitude\n  locs <- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n  \n  # Populate a column in the data frame with the POLYGON call for each location\n  locs <- add_polygon_col(locs)\n  saveRDS(locs, file = \"locs.rds\")\n}\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nui <- fluidPage(\n  \n  # Application title\n  titlePanel(\"Organism migration tracking\"),\n  \n  # Sidebar with a slider input for number of bins \n  sidebarLayout(\n    sidebarPanel(\n      sightingsInput(\"plot1\", \"Plot 1\", specs, locs)\n    ),\n    \n    # Show a plot of the generated distribution\n    mainPanel(\n      sightingsOutput(\"plot1\", \"Plot 1\")\n    )\n  )\n)\n\n#### Server function ####\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n  sightingsServer(\"plot1\", specs, locs)\n}\n\n#### Run app ####\nshinyApp(ui = ui, server = server)\n```\n\n#### Multiple instances\n\nThe file **app.R** with the shiny app using multiple instances of the same module.\n\n``` r\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app for plotting species occurrence from GBIF.                        #\n###############################################################################\n\n#### Imports ####\nrequire(shiny)\nrequire(tidygeocoder)\n\nsource(\"../R/plot_sightings.R\")\nsource(\"../R/add_polygon_col.R\")\nsource(\"../R/sightingsModule.R\")\n\n#### Setup ####\n# Set up a dataframe to use connecting names with species\nspecs <- tibble::tribble(\n  ~name,                        ~species,                 ~short_name,    ~clr,\n  \"Monarch Butterfly\",          \"Danaus plexippus\",       \"Monarch\",      \"cyan\",\n  \"Northern Cardinal\",          \"Cardinalis cardinalis\",  \"Cardinal\",     \"red\",\n  \"Ruby Throated Hummingbird\",  \"Archilochus colubris\",   \"Hummingbird\",  \"pink\",\n  \"White-Throated Sparrow\",     \"Zonotrichia albicollis\", \"Sparrow\",      \"yellow\"\n)\n\n# Create the table of possible cities to check\nlocs <- tibble::tribble(\n  ~name,            ~address,\n  \"Evansville\",     \"Evansville, IN\",\n  \"West Lafayette\", \"West Lafayette, IN 47907\", \n  \"Davis\",          \"Davis, CA\",\n  \"Seattle\",        \"Seattle, WA\",\n  \"New Jersey\",     \"New Jersey, NY\",\n  \"Miami\",          \"Miami, FL\",\n  \"LA\",             \"Los Angelos, CA\"\n)\n# Variable to keep track of whether data needs to be reloaded\nreload_data <- TRUE\nif (file.exists(\"locs.rds\")) {\n  locs2 <- readRDS(\"locs.rds\")\n  \n  if (dplyr::all_equal(locs, locs2[,1:2]) & ncol(locs2) == 5) {\n    locs <- locs2\n    reload_data <- FALSE\n  }\n} \n\nif (reload_data) {\n  # Get latitude and longitude\n  locs <- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n  \n  # Populate a column in the data frame with the POLYGON call for each location\n  locs <- add_polygon_col(locs)\n  saveRDS(locs, file = \"locs.rds\")\n}\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nui <- fluidPage(\n  \n  # Application title\n  titlePanel(\"Organism migration tracking\"),\n  \n  # Sidebar with a slider input for number of bins \n  sidebarLayout(\n    sidebarPanel(\n      sightingsInput(\"plot1\", \"Plot 1\", specs, locs, sel = \"Monarch Butterfly\"),\n      sightingsInput(\"plot2\", \"Plot 2\", specs, locs, sel = \"Northern Cardinal\"),\n      sightingsInput(\"plot3\", \"Plot 3\", specs, locs, sel = \"Ruby Throated Hummingbird\"),\n      sightingsInput(\"plot4\", \"Plot 4\", specs, locs, sel = \"White-Throated Sparrow\")\n    ),\n    \n    # Show a plot of the generated distribution\n    mainPanel(\n      sightingsOutput(\"plot1\", \"Plot 1\"),\n      sightingsOutput(\"plot2\", \"Plot 2\"),\n      sightingsOutput(\"plot3\", \"Plot 3\"),\n      sightingsOutput(\"plot4\", \"Plot 4\")\n    )\n  )\n)\n\n#### Server function ####\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n  sightingsServer(\"plot1\", specs, locs)\n  sightingsServer(\"plot2\", specs, locs)\n  sightingsServer(\"plot3\", specs, locs)\n  sightingsServer(\"plot4\", specs, locs)\n}\n\n#### Run app ####\nshinyApp(ui = ui, server = server)\n```\n\nHere's what it looks like:\n\n![](shiny_app_with_modules.png){fig-align=\"center\"}\n\n### More Shiny things to try on your own\n\n-   Install `bslib` package and test out additional formatting options including `card()` for nice cards\n\n    -   <https://rstudio.github.io/bslib/articles/cards/#shiny>\n\n-   Convert Shiny code to work in Quarto\n\n    -   App complexity is limited to what can run in a browser\n    -   This has more support for Shiny in python than in R\n\n-   Add Caching to your Shiny app for faster loading without re-downloading or re-processing data that hasn't changed.\n\n    -   <https://shiny.posit.co/r/articles/improve/caching/>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}