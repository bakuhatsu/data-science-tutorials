[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/shiny-apps/index.html",
    "href": "posts/shiny-apps/index.html",
    "title": "Shiny apps in R",
    "section": "",
    "text": "Parts of a Shiny app\nWhen to use a Shiny app\nWhen not to use a Shiny app\n\nAlternatives: Rmarkdown/Quarto, Jupyter notebooks can do R, R script and output figures"
  },
  {
    "objectID": "posts/shiny-apps/index.html#brief-introduction-to-shiny",
    "href": "posts/shiny-apps/index.html#brief-introduction-to-shiny",
    "title": "Shiny apps in R",
    "section": "",
    "text": "Parts of a Shiny app\nWhen to use a Shiny app\nWhen not to use a Shiny app\n\nAlternatives: Rmarkdown/Quarto, Jupyter notebooks can do R, R script and output figures"
  },
  {
    "objectID": "posts/shiny-apps/index.html#step-by-step-script-to-shiny-app",
    "href": "posts/shiny-apps/index.html#step-by-step-script-to-shiny-app",
    "title": "Shiny apps in R",
    "section": "Step-by-step script to Shiny app",
    "text": "Step-by-step script to Shiny app\n\nWalk through the process of starting with an R script and then ending with a Shiny app\n\n\nSelecting a dataset\nLet’s use a fun dataset. This post produced the GIF below in R showing monarch butterfly migrations.\n\nhttps://medium.com/@jakeamahr/using-rgbif-to-visualize-annual-monarch-butterfly-migrations-f34a335b77f1\n\n\n\nMonarch Butterfly Migrations\n\n\nWe won’t replicate this (you can follow the link if you would like to do that), but we can use the same data source.\n\nThe Global Biodiversity Information Facility (GBIF) is a free an open access database with a lot of information that can be mined about all different species of organisms.\n\nhttps://www.gbif.org/\nThere is an R package that makes it easy to access this data:\n\nhttps://www.gbif.org/tool/81747/rgbif\nhttps://docs.ropensci.org/rgbif/index.html\n\nThis page has a lot of examples and information on how to use the package\n\nYou can make a free account and download larger datasets, but we will just use the occ_count() function that doesn’t require an account.\n\nIf you do create an account at gbid.org, you can set it up for use in R using the following link:\n\nhttps://docs.ropensci.org/rgbif/articles/gbif_credentials.html\n\nThen you can use the function occ_download() which will query the full database\n\n\n\n\n\nStart with an R script\n\nEasier to work out the kinks for a single example\nCan run line-by-line to test the outputs at each step and correct any issues\n\n\nlibrary(rgbif)\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✔ ggplot2 3.5.1     ✔ purrr   1.0.1\n✔ tibble  3.2.1     ✔ dplyr   1.1.2\n✔ tidyr   1.3.0     ✔ stringr 1.5.1\n✔ readr   2.0.0     ✔ forcats 0.5.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n# Get monarch taxonKey\nmonarch &lt;- name_backbone(\"Danaus plexippus\")$usageKey\n\n# remember to set up your GBIF credentials to use occ_download()\n# test &lt;- rgbif::occ_download(pred(\"taxonKey\", monarch),format = \"SIMPLE_CSV\")\n\n# Evansville and surrounding area\nwkt &lt;- \"POLYGON((-88.54 38.54, -88.54 37.80, -86.74 37.80, -86.74 38.54, -88.54 38.54))\"\nEV_monarchs &lt;- occ_count(facet=c(\"month\"), taxonKey=monarch, geometry=wkt)\n\nlibrary(tidyverse)\n# Make month columns into integers\nEV_monarchs$month &lt;- as.numeric(EV_monarchs$month)\n# Fill in missing months with 0 values\nfor (i in 1:12) {\n  if (!(i %in% EV_monarchs$month)) {\n    EV_monarchs &lt;- add_row(EV_monarchs, month = i, count = 0)\n  }\n}\n\n# Order rows by month\nEV_monarchs &lt;- arrange(EV_monarchs, month)\n\n# Make column with text month names\nEV_monarchs &lt;- mutate(EV_monarchs, Month = month.abb[month])\n\n# Make Month column factors\nEV_monarchs$Month &lt;- factor(EV_monarchs$Month, levels = EV_monarchs$Month)\n\n# Plot the data as a barplot with occurrences for each month\nlibrary(ggplot2)\nggplot(EV_monarchs, aes(x = Month, y = count)) + # , fill = count\n  geom_bar(stat=\"identity\", color=\"black\", fill = \"cyan\") + \n  xlab(\"Time of year\") + \n  ylab(\"Occurrences\") + \n  ggtitle(\"Monarchs in Evansville\") +\n  # scale_fill_gradient(low=\"cyan\", high=\"cyan\") +\n  theme_bw() + \n  theme(panel.border = element_blank(), panel.grid.major = element_blank(),\npanel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\")) \n\n\n\n\n\n\n\n\n\n\nNext, convert this script into a function\n\nDetermine what the parameters will be (variables that you will change)\n\nIt would be nice to see the same graphs for monarch butterflies from other locations\nIt would be nice to see the same graphs for different species\n\nChange names are are specific like “EV_monarchs” to something not specific to the location (EV) or species (monarchs) so that the code reads well regardless of what these 2 variables are set to.\nFor functions, I generally change library() to require()\n\nThe only difference is that require won’t re-load a package if it is already loaded\nThis is optional, since library() will still work\nRemove duplicates so you only load each library once (unless necessary to reload in a different order)\nFor functions like filter() which exist in multiple packages, always call with :: specifying the package\n\nAlways use dplyr::filter() never filter()\n\n\nImprove your comments here as you go to specify what each step is (what each line is doing)\nIf your output is a plot, instead of just plotting, return the plot object at the end\n\nIf you just let it return, it will plot, but you can also save the output to a variable and modify settings later. (In this case, we will do this to change the bar colors for each duplicate plot.)\n\n\n\nplot_sightings &lt;- function(species = \"Danaus plexippus\", location = wkt, title = \"Monarchs in Evansville\") {\n  require(rgbif)\n  require(tidyverse)\n  \n  # Get species taxonKey\n  spec_id &lt;- name_backbone(species)$usageKey\n  \n  # Get data from rgbif for the passed species at the passed location\n  sightings &lt;- occ_count(facet=c(\"month\"), taxonKey=spec_id, geometry=location)\n  \n  library(tidyverse)\n  # Make month columns into integers\n  sightings$month &lt;- as.numeric(sightings$month)\n  # Fill in missing months with 0 values\n  for (i in 1:12) {\n    if (!(i %in% sightings$month)) {\n      sightings &lt;- add_row(sightings, month = i, count = 0)\n    }\n  }\n  \n  # Order rows by month\n  sightings &lt;- arrange(sightings, month)\n  \n  # Make column with text month names\n  sightings &lt;- mutate(sightings, Month = month.abb[month])\n  \n  # Make Month column factors\n  sightings$Month &lt;- factor(sightings$Month, levels = sightings$Month)\n  \n  # Plot the data as a barplot with occurrences for each month\n  plt &lt;- ggplot(sightings, aes(x = Month, y = count)) + # , fill = count\n    geom_bar(stat=\"identity\", color=\"black\", fill = \"cyan\") + \n    xlab(\"Time of year\") + \n    ylab(\"Occurrences\") + \n    ggtitle(title) +\n    theme_bw() + \n    theme(panel.border = element_blank(), panel.grid.major = element_blank(),\n  panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\")) \n  \n  return(plt)\n}\n\nNow to run it we can do:\n\nNote that output plot size is set here for Quarto with {r fig.width=4, fig.height=2} for the code block\nWe will have to set this in our Shiny app in a different way later\n\n\n# Monarch butterfly (Danaus plexippus)\nplot_sightings(species = \"Danaus plexippus\", location = wkt, \"Monarchs in Evansville\")\n\n\n\n\n\n\n\n# Northern Cardinal (Cardinalis cardinalis)\nplot_sightings(species = \"Cardinalis cardinalis\", location = wkt, \"Cardinals in Evansville\") + \n  geom_bar(stat=\"identity\", color=\"black\", fill = \"red\")\n\n\n\n\n\n\n\n# Ruby Throated Hummingbird (Archilochus colubris)\nplot_sightings(species = \"Archilochus colubris\", location = wkt, \"Hummingbirds in Evansville\") + \n  geom_bar(stat=\"identity\", color=\"black\", fill = \"pink\")\n\n\n\n\n\n\n\n# White-Throated Sparrow (Zonotrichia albicollis)\nplot_sightings(species = \"Zonotrichia albicollis\", location = wkt, \"Sparrows in Evansville\") + \n  geom_bar(stat=\"identity\", color=\"black\", fill = \"yellow\")\n\n\n\n\n\n\n\n\n\n\nHelper functions\nSometimes a variable is not simply a single word, number, or boolean. In this case, you may need to define additional functions to create the variable given a simpler input\n\nlocation is set with:\n\n# Evansville and surrounding area\nwkt &lt;- \"POLYGON((-88.54 38.54, -88.54 37.80, -86.74 37.80, -86.74 38.54, -88.54 38.54))\"\n\nThese are the four corners of a rectangle as Latitude and Longitude in counterclockwise direction around the rectangle (the direction is important, clockwise will exclude the area inside)\nI defined this manually using the tool here and Apple/Google Maps\n\nhttps://www.gbif.org/occurrence/search?basis_of_record=HUMAN_OBSERVATION&has_coordinate=true&has_geospatial_issue=false&taxon_key=5133088&year=1990,2024&geometry=POLYGON((-88.54438%2037.48459,-86.74461%2037.48459,-86.74461%2038.86468,-88.54438%2038.86468,-88.54438%2037.48459))\n\nTo simplify this, it would be nice to have a function that takes either a single Latitude and Longitude or a city name and generates the wkt output.\n\n\nlibrary(tidygeocoder)\n\n# Create table of possible cities to check\nlocs &lt;- tibble::tribble(\n~name,            ~address,\n\"Evansville\",     \"Evansville, IN\",\n\"West Lafayette\", \"West Lafayette, IN 47907\", \n\"Davis\",          \"Davis, CA\",\n\"Seattle\",        \"Seattle, WA\",\n\"New Jersey\",     \"New Jersey, NY\",\n\"Miami\",          \"Miami, FL\",\n\"LA\",             \"Los Angelos, CA\"\n)\n\n# Get latitude and longitude\nlocs &lt;- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n\nPassing 7 addresses to the Nominatim single address geocoder\n\n\nQuery completed in: 7 seconds\n\n# Create function to generate string with 4 corners for POLYGON call\ngenerate_polygon &lt;- function(lat, long, d_lg=0.9, d_lt=0.37) {\n  # \"POLYGON((-88.54 38.54, -88.54 37.80, -86.74 37.80, -86.74 38.54, -88.54 38.54))\"\n  p = paste0(\"POLYGON((\",\n             long-d_lg, \" \", lat+d_lt, \", \",\n             long-d_lg,\" \", lat-d_lt, \", \",\n             long+d_lg,\" \", lat-d_lt, \", \",\n             long+d_lg,\" \", lat+d_lt, \", \",\n             long-d_lg, \" \", lat+d_lt,\n             \"))\")\n  return(p)\n}\n\n# Test function with anu location\nanu &lt;- generate_polygon(locs$latitude[1], locs$longitude[1])\n\n# Monarch butterfly (Danaus plexippus) at anu\nplot_sightings(species = \"Danaus plexippus\", location = anu)\n\n\n\n\n\n\n\n# Populate a column in the data frame with the POLYGON call for each location\nlocs2 &lt;- mutate(locs, polygon = generate_polygon(locs$latitude, locs$longitude))\n## THIS DOESN'T WORK BECAUSE PASTE IS NOT VECTORIZED\n\n# Create function to generate string with 4 corners for POLYGON call\ngenerate_polygon &lt;- function(lat, long, d_lg=0.9, d_lt=0.37) {\n  # Paste is not vectorize, use sprintf instead (limit decimals to 4 places)\n  p = sprintf(\"POLYGON((%.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f))\", \n              long-d_lg, lat+d_lt, \n              long-d_lg, lat-d_lt,\n              long+d_lg, lat-d_lt,\n              long+d_lg, lat+d_lt,\n              long-d_lg, lat+d_lt\n              )\n  return(p)\n}\n\n# Populate a column in the data frame with the POLYGON call for each location\nlocs &lt;- mutate(locs, polygon = generate_polygon(locs$latitude, locs$longitude))\n## THIS WORKS NOW\n\n# Plot all locations\nfor (i in 1:nrow(locs)) {\n  plt &lt;- plot_sightings(species = \"Danaus plexippus\", location = locs$polygon[i], \n                        paste0(\"Monarchs in \", locs$name[i]))\n  print(plt)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse manipulate() in RStudio for quick and simple interactive plotting\n\nThe manipulate package only works in RStudio, but it gives you a very quick and simple way to get drop downs and other selectors like you would do in a Shiny app without a lot of coding.\nYou can use these sorts of controls:\n\nSliders\nDropdown pickers\nCheckboxes\nAnd combinations of the above\n\n# Very simple example to make sure manipulate is working\nlibrary(manipulate)\nmanipulate(plot(1:X), X = slider(1, 10))\nMore info here:\n\nhttps://support.posit.co/hc/en-us/articles/200551906-Interactive-Plotting-with-Manipulate-in-the-RStudio-IDE\n\nA simple example using our dataset and function:\n\nlibrary(manipulate)\n\nmanipulate(\n  plot_sightings(species = Species, location = locs$polygon[1], \n                        paste0(\"Monarchs in \", locs$name[1])),\n  Species = picker(\n    \"Monarch Butterfly\" = \"Danaus plexippus\", \n    \"Northern Cardinal\" = \"Cardinalis cardinalis\", \n    \"Ruby Throated Hummingbird\" = \"Archilochus colubris\",\n    \"White-Throated Sparrow\" = \"Zonotrichia albicollis\"),\n  Location = picker(\n    \"Evansville\" = \"Evansville, IN\",\n    \"West Lafayette\" = \"West Lafayette, IN 47907\", \n    \"Davis\" = \"Davis, CA\",\n    \"Seattle\" = \"Seattle, WA\",\n    \"New Jersey\" = \"New Jersey, NY\",\n    \"Miami\" = \"Miami, FL\",\n    \"LA\" = \"Los Angelos, CA\"\n  )\n)\n\nYou can’t view manipulate in the browser, so I’ll paste a screenshot here and show a live demo during the tutorial:\n\nAnother similar package that I haven’t tried based on manipulate is manipulateWidget\n\nhttps://cran.r-project.org/web/packages/manipulateWidget/vignettes/manipulateWidgets.html\n\n\n\n\nNow on to a Shiny app\n\nA Shiny app gives you more control over the look and feel, more options as far as the ways to interact or display your data, and can run in a web browser locally or across the internet without requiring the viewer to have R or your code running on their system.\n\nHelper function add_polygon_col.R:\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Function for generating a polygon with 4 corners for RGBIF                  #\n###############################################################################\n\nrequire(tidygeocoder)\n\n# Function to return df with polygon column\nadd_polygon_col &lt;- function(df) {\n  # Create function to generate string with 4 corners for POLYGON call\n  generate_polygon &lt;- function(lat, long, d_lg=0.9, d_lt=0.37) {\n    # Paste is not vectorize, use sprintf instead (limit decimals to 4 places)\n    p = sprintf(\"POLYGON((%.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f, %.4f %.4f))\", \n                long-d_lg, lat+d_lt, \n                long-d_lg, lat-d_lt,\n                long+d_lg, lat-d_lt,\n                long+d_lg, lat+d_lt,\n                long-d_lg, lat+d_lt\n    )\n    return(p)\n  }\n  # Populate a column in the data frame with the POLYGON call for each location\n  df &lt;- mutate(df, polygon = generate_polygon(df$latitude, df$longitude))\n  return(df)\n}\napp.R:\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app for plotting species occurrence from GBIF.                        #\n###############################################################################\n\n#### Imports ####\nrequire(shiny)\nrequire(tidygeocoder)\nrequire(memoise)\n\nsource(\"../R/plot_sightings.R\")\nsource(\"../R/add_polygon_col.R\")\n\n#### Setup ####\n# Set up a dataframe to use connecting names with species\nspecs &lt;- tibble::tribble(\n  ~name,                        ~species,                 ~short_name,    ~clr,\n  \"Monarch Butterfly\",          \"Danaus plexippus\",       \"Monarch\",      \"cyan\",\n  \"Northern Cardinal\",          \"Cardinalis cardinalis\",  \"Cardinal\",     \"red\",\n  \"Ruby Throated Hummingbird\",  \"Archilochus colubris\",   \"Hummingbird\",  \"pink\",\n  \"White-Throated Sparrow\",     \"Zonotrichia albicollis\", \"Sparrow\",      \"yellow\"\n)\n\n# Create the table of possible cities to check\nlocs &lt;- tibble::tribble(\n  ~name,            ~address,\n  \"Evansville\",     \"Evansville, IN\",\n  \"West Lafayette\", \"West Lafayette, IN 47907\", \n  \"Davis\",          \"Davis, CA\",\n  \"Seattle\",        \"Seattle, WA\",\n  \"New Jersey\",     \"New Jersey, NY\",\n  \"Miami\",          \"Miami, FL\",\n  \"LA\",             \"Los Angelos, CA\"\n)\n# Variable to keep track of whether data needs to be reloaded\nreload_data &lt;- TRUE\nif (file.exists(\"locs.rds\")) {\n  locs2 &lt;- readRDS(\"locs.rds\")\n  \n  if (dplyr::all_equal(locs, locs2[,1:2]) & ncol(locs2) == 5) {\n    locs &lt;- locs2\n    reload_data &lt;- FALSE\n  }\n} \n\nif (reload_data) {\n  # Get latitude and longitude\n  locs &lt;- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n  \n  # Populate a column in the data frame with the POLYGON call for each location\n  locs &lt;- add_polygon_col(locs)\n  saveRDS(locs, file = \"locs.rds\")\n}\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n  # Application title\n  titlePanel(\"Organism migration tracking\"),\n\n  # Sidebar with a slider input for number of bins \n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"spec_pick\", \"Organism\", choices = specs$name),\n      selectInput(\"loc_pick\", \"Location\", choices = locs$name)\n    ),\n\n    # Show a plot of the generated distribution\n    mainPanel(\n      plotOutput(\"sightingsPlot\", width = 400, height = 200) # Set size here\n    )\n  )\n)\n\n#### Server function ####\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n  output$sightingsPlot &lt;- renderPlot({\n    # generate bins based on input$bins from ui.R\n    sp_nm &lt;- input$spec_pick\n    lc_nm &lt;- input$loc_pick\n    sp &lt;- specs[specs$name == sp_nm,]$species\n    sp_col &lt;- specs[specs$name == sp_nm,]$clr\n    lc &lt;- locs[locs$name == lc_nm,]$polygon\n    \n    plot_sightings(species = sp, location = lc, paste0(sp_nm, \" in \", lc_nm)) + \n      geom_bar(stat=\"identity\", color=\"black\", fill = sp_col)\n  })\n}\n\n#### Run app ####\nshinyApp(ui = ui, server = server)\n\n\nShiny Modules\n\nConvert to module\n\nhttps://shiny.posit.co/r/articles/improve/modules/\nWe will end up with a .R file with the module code, which we can run in a app.R shiny app.\n\n\nThe file sightingsModule.R below:\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app module for plotting species occurrence from GBIF.                 #\n###############################################################################\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nsightingsInput &lt;- function(id, label = \"Sightings\", specs, locs, sel = \"Monarch Butterfly\") {\n  ns &lt;- NS(id)\n  tagList(\n    h4(label),\n    selectInput(ns(\"spec_pick\"), \"Organism\", choices = specs$name, selected = sel),\n    selectInput(ns(\"loc_pick\"), \"Location\", choices = locs$name)\n  )\n}\n\nsightingsOutput &lt;- function(id, label = \"Sightings\") {\n  ns &lt;- NS(id)\n  tagList(\n    plotOutput(ns(\"sightingsPlot\"), width = 400, height = 200)\n  )\n}\n\n#### Server function ####\n# Define server logic required to draw a histogram\nsightingsServer &lt;- function(id, specs, locs) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      output$sightingsPlot &lt;- renderPlot({\n        # generate bins based on input$bins from ui.R\n        sp_nm &lt;- input$spec_pick\n        lc_nm &lt;- input$loc_pick\n        sp &lt;- specs[specs$name == sp_nm,]$species\n        sp_col &lt;- specs[specs$name == sp_nm,]$clr\n        lc &lt;- locs[locs$name == lc_nm,]$polygon\n        \n        plot_sightings(species = sp, location = lc, paste0(sp_nm, \" in \", lc_nm)) + \n          geom_bar(stat=\"identity\", color=\"black\", fill = sp_col)\n      })\n    }\n  )\n}\nThe file app.R with the shiny app using a single instance of the same module.\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app for plotting species occurrence from GBIF.                        #\n###############################################################################\n\n#### Imports ####\nrequire(shiny)\nrequire(tidygeocoder)\n\nsource(\"../R/plot_sightings.R\")\nsource(\"../R/add_polygon_col.R\")\nsource(\"../R/sightingsModule.R\")\n\n#### Setup ####\n# Set up a dataframe to use connecting names with species\nspecs &lt;- tibble::tribble(\n  ~name,                        ~species,                 ~short_name,    ~clr,\n  \"Monarch Butterfly\",          \"Danaus plexippus\",       \"Monarch\",      \"cyan\",\n  \"Northern Cardinal\",          \"Cardinalis cardinalis\",  \"Cardinal\",     \"red\",\n  \"Ruby Throated Hummingbird\",  \"Archilochus colubris\",   \"Hummingbird\",  \"pink\",\n  \"White-Throated Sparrow\",     \"Zonotrichia albicollis\", \"Sparrow\",      \"yellow\"\n)\n\n# Create the table of possible cities to check\nlocs &lt;- tibble::tribble(\n  ~name,            ~address,\n  \"Evansville\",     \"Evansville, IN\",\n  \"West Lafayette\", \"West Lafayette, IN 47907\", \n  \"Davis\",          \"Davis, CA\",\n  \"Seattle\",        \"Seattle, WA\",\n  \"New Jersey\",     \"New Jersey, NY\",\n  \"Miami\",          \"Miami, FL\",\n  \"LA\",             \"Los Angelos, CA\"\n)\n# Variable to keep track of whether data needs to be reloaded\nreload_data &lt;- TRUE\nif (file.exists(\"locs.rds\")) {\n  locs2 &lt;- readRDS(\"locs.rds\")\n  \n  if (dplyr::all_equal(locs, locs2[,1:2]) & ncol(locs2) == 5) {\n    locs &lt;- locs2\n    reload_data &lt;- FALSE\n  }\n} \n\nif (reload_data) {\n  # Get latitude and longitude\n  locs &lt;- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n  \n  # Populate a column in the data frame with the POLYGON call for each location\n  locs &lt;- add_polygon_col(locs)\n  saveRDS(locs, file = \"locs.rds\")\n}\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n  \n  # Application title\n  titlePanel(\"Organism migration tracking\"),\n  \n  # Sidebar with a slider input for number of bins \n  sidebarLayout(\n    sidebarPanel(\n      sightingsInput(\"plot1\", \"Plot 1\", specs, locs)\n    ),\n    \n    # Show a plot of the generated distribution\n    mainPanel(\n      sightingsOutput(\"plot1\", \"Plot 1\")\n    )\n  )\n)\n\n#### Server function ####\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n  sightingsServer(\"plot1\", specs, locs)\n}\n\n#### Run app ####\nshinyApp(ui = ui, server = server)\n\nMultiple instances\nThe file app.R with the shiny app using multiple instances of the same module.\n###############################################################################\n# Sven Nelson                                                                 #\n# 6/24/2024                                                                   #\n# Shiny app for plotting species occurrence from GBIF.                        #\n###############################################################################\n\n#### Imports ####\nrequire(shiny)\nrequire(tidygeocoder)\n\nsource(\"../R/plot_sightings.R\")\nsource(\"../R/add_polygon_col.R\")\nsource(\"../R/sightingsModule.R\")\n\n#### Setup ####\n# Set up a dataframe to use connecting names with species\nspecs &lt;- tibble::tribble(\n  ~name,                        ~species,                 ~short_name,    ~clr,\n  \"Monarch Butterfly\",          \"Danaus plexippus\",       \"Monarch\",      \"cyan\",\n  \"Northern Cardinal\",          \"Cardinalis cardinalis\",  \"Cardinal\",     \"red\",\n  \"Ruby Throated Hummingbird\",  \"Archilochus colubris\",   \"Hummingbird\",  \"pink\",\n  \"White-Throated Sparrow\",     \"Zonotrichia albicollis\", \"Sparrow\",      \"yellow\"\n)\n\n# Create the table of possible cities to check\nlocs &lt;- tibble::tribble(\n  ~name,            ~address,\n  \"Evansville\",     \"Evansville, IN\",\n  \"West Lafayette\", \"West Lafayette, IN 47907\", \n  \"Davis\",          \"Davis, CA\",\n  \"Seattle\",        \"Seattle, WA\",\n  \"New Jersey\",     \"New Jersey, NY\",\n  \"Miami\",          \"Miami, FL\",\n  \"LA\",             \"Los Angelos, CA\"\n)\n# Variable to keep track of whether data needs to be reloaded\nreload_data &lt;- TRUE\nif (file.exists(\"locs.rds\")) {\n  locs2 &lt;- readRDS(\"locs.rds\")\n  \n  if (dplyr::all_equal(locs, locs2[,1:2]) & ncol(locs2) == 5) {\n    locs &lt;- locs2\n    reload_data &lt;- FALSE\n  }\n} \n\nif (reload_data) {\n  # Get latitude and longitude\n  locs &lt;- geocode(locs, address, method = \"osm\", lat = latitude, long = longitude)\n  \n  # Populate a column in the data frame with the POLYGON call for each location\n  locs &lt;- add_polygon_col(locs)\n  saveRDS(locs, file = \"locs.rds\")\n}\n\n#### User Interface ####\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n  \n  # Application title\n  titlePanel(\"Organism migration tracking\"),\n  \n  # Sidebar with a slider input for number of bins \n  sidebarLayout(\n    sidebarPanel(\n      sightingsInput(\"plot1\", \"Plot 1\", specs, locs, sel = \"Monarch Butterfly\"),\n      sightingsInput(\"plot2\", \"Plot 2\", specs, locs, sel = \"Northern Cardinal\"),\n      sightingsInput(\"plot3\", \"Plot 3\", specs, locs, sel = \"Ruby Throated Hummingbird\"),\n      sightingsInput(\"plot4\", \"Plot 4\", specs, locs, sel = \"White-Throated Sparrow\")\n    ),\n    \n    # Show a plot of the generated distribution\n    mainPanel(\n      sightingsOutput(\"plot1\", \"Plot 1\"),\n      sightingsOutput(\"plot2\", \"Plot 2\"),\n      sightingsOutput(\"plot3\", \"Plot 3\"),\n      sightingsOutput(\"plot4\", \"Plot 4\")\n    )\n  )\n)\n\n#### Server function ####\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n  sightingsServer(\"plot1\", specs, locs)\n  sightingsServer(\"plot2\", specs, locs)\n  sightingsServer(\"plot3\", specs, locs)\n  sightingsServer(\"plot4\", specs, locs)\n}\n\n#### Run app ####\nshinyApp(ui = ui, server = server)\nHere’s what it looks like:\n\n\n\n\n\n\n\n\nMore Shiny things to try on your own\n\nInstall bslib package and test out additional formatting options including card() for nice cards\n\nhttps://rstudio.github.io/bslib/articles/cards/#shiny\n\nConvert Shiny code to work in Quarto\n\nApp complexity is limited to what can run in a browser\nThis has more support for Shiny in python than in R\n\nAdd Caching to your Shiny app for faster loading without re-downloading or re-processing data that hasn’t changed.\n\nhttps://shiny.posit.co/r/articles/improve/caching/"
  },
  {
    "objectID": "posts/ggplot2/index.html",
    "href": "posts/ggplot2/index.html",
    "title": "Getting to know ggplot2",
    "section": "",
    "text": "What is ggplot2?\nggplot2 is a way to declaratively create graphics, meaning that you control all aspects of how you want your plot to look. ggplot2 takes in data frames, you provide the aesthetics and the details of what you’d like to see on your plot.\n\n\nStructure of a ggplot\n\nData\n\nWhat information do we want to show from the data collected? Can we determine if there is a connection between two variables?\n\nAnu example: relationship between light recipe and plant weight.\n\n\nGeometry\n\nWhat is the best way to communicate what the data is showing us?\n\nScatter plot? Bar plot? Line plot? Other?\n\n\nAesthetics\n\nHow do we want the plot to look?\n\nTheme, colors, shapes, error bars.\n\n\n\n\n\nBuild a simple plot - scatter plot\n\n# Install tidyverse package, or alternatively just install ggplot2\n# install.packages(\"tidyverse\")\n# Install palmerpenguins to get access to penguins dataset\n# install.packages(\"palmerpenguins\")\n# install.packages(\"shinylive\")\n\n# Load library\nlibrary(ggplot2) \nlibrary(palmerpenguins)\n# Load palmer penguins data\n# data(package = 'palmerpenguins')\n\n# Read in your df\ndf &lt;- penguins\n\n# Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. Aesthetic mappings can be set in ggplot() and in individual layers.\n\n# Basic plot\np_simple &lt;- ggplot(df, aes(x = body_mass_g, y = bill_length_mm, color = species)) +\n  # Include a \"+\" symbol at the end of each line when adding additional components\n  geom_point()\np_simple\n\n\n\n\n\n\n\n\n\n\nHow do we build on this?\n\n# Additional features to make the plot look prettier\n# Change the shapes of the dots of each species\np &lt;- ggplot(df, aes(x = body_mass_g, y = bill_length_mm, color = species, shape = species)) + \n  geom_point() +\n  # Add trend line, with method = linear regression (lm = linear model)\n  geom_smooth(method = lm, se=FALSE) +\n  # Add a title\n  ggtitle(paste0(\"Body Mass (g) vs. Bill Length (mm)\")) +\n  # Increase the number of x-axis ticks\n  scale_x_continuous(breaks = round(seq(min(df$body_mass_g, na.rm = TRUE), max(df$body_mass_g, na.rm = TRUE), by = 500),1)) +\n  # Increase the number of y-axis ticks\n  scale_y_continuous(breaks = round(seq(min(df$bill_length_mm, na.rm = TRUE), max(df$bill_length_mm, na.rm = TRUE), by = 5),1)) +\n  # Makes background white, looks a little cleaner\n  theme_bw()\n\np\n\n\n\n\n\n\n\n\n\n\nOther ways to visualize this data\n\n# Facet data by species\nfacet_plot &lt;- p + \n  # Facet data based on penguin species\n  # Scales options are: \"fixed\", \"free\", \"free_x\", \"free_y\" - fixed = default\n  facet_wrap(facets = df$species, scales = \"fixed\") +\n  # Format the text at the bottom of the plots so that it's at a 45 degree angle\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))\nfacet_plot\n\n\n\n\n\n\n\n\n\n\nOther plot types\n\nBar plot\n\n# Want to plot average size of each variety of penguin in a specific year - bar plot\nlibrary(Rmisc) \nlibrary(magrittr)\nlibrary(ggplot2)\n# Need to summarize data\nsumm_data &lt;- summarySE(data = df, measurevar = \"body_mass_g\", groupvars = c(\"species\", \"year\", \"sex\"))\n\n# Filter data to only include data from 2007 for female penguins\nfiltered_data &lt;- summ_data %&gt;% \n  dplyr::filter(year == \"2007\" & sex == \"female\")\n\nggplot(filtered_data, aes(x = species, y= body_mass_g, fill = species)) +\n  geom_bar(stat=\"identity\", color=\"black\", position=position_dodge(), size = 0.5, width = 0.5) +\n  # Add error bars\n  geom_errorbar(aes(ymin=body_mass_g - se, ymax=body_mass_g + se), width=.1) +\n  theme_bw()\n\n\n\n\n\n\n\n# geom_bar() notes\n  # Stat = identity tells R to use the provided y values directly, instead of doing other statistics\n  # position = position_dodge() adjusts the placement of the bars on a bar plot\n  # Specify size and width of the bars in the bar plot\n\n# geom_errorbar() notes\n  # calculate ymin and ymax\n  # position_dodge() - same as geom_bar\n  # set width of error bars\n\n\n\n\nggplot2 in R Shiny\n#| standalone: true\n#| viewerHeight: 600\nlibrary(shiny)\nlibrary(bslib)\nlibrary(palmerpenguins)\nlibrary(ggplot2)\n\n\n# Define UI for app that draws a histogram ----\nui &lt;- page_sidebar(\n  sidebar = sidebar(open = \"open\",\n    #selectInput(inputId = \"select_year\", label = \"Select Year\", choices = c(choices_year)),\n  selectInput(inputId = \"select_year\", label = \"Select Year\", choices = c(2007, 2008, 2009)),\n    selectInput(inputId = \"sex\", label = \"Select Sex\", choices = c(\"female\", \"male\"))\n  ),\n  plotOutput(\"plot\")\n)\n\nserver &lt;- function(input, output, session) {\n  reactive_data &lt;- reactive({\n    df &lt;- palmerpenguins::penguins\n    # Summarize data\n    sum_data &lt;- Rmisc::summarySE(df, measurevar = \"body_mass_g\", groupvars = c(\"species\", \"year\", \"sex\"), na.rm = TRUE)\n    # sum_data$sex &lt;- as.character(sum_data$sex)\n    # Filter data\n    dplyr::filter(sum_data, year == input$select_year & sex == input$sex)\n    \n    # ggplot(new_data, aes(x = species, y= body_mass_g, fill = species)) +\n    # geom_bar(stat=\"identity\", color=\"black\", position=position_dodge(), size = 0.5, width = 0.5) +\n    # # Add error bars\n    # geom_errorbar(aes(ymin=body_mass_g - se, ymax=body_mass_g + se), width=.1) +\n    # theme_bw()\n  })\n  \n  output$plot &lt;- renderPlot({\n  ggplot(reactive_data(), aes(x = species, y= body_mass_g, fill = species)) +\n    geom_bar(stat=\"identity\", color=\"black\", position=position_dodge(), size = 0.5, linewidth = 0.5) +\n  #   # Add error bars\n    geom_errorbar(aes(ymin=body_mass_g - se, ymax=body_mass_g + se), width=.1) +\n    theme_bw()\n    # reactive_data()\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\n\nggplotly\n\nGives the ability to turn a ggplot object to a plotly object\nAllows for easy viewing of data points in a congested plot\n\n\nlibrary(plotly)\nggplotly(facet_plot)\n\n\n\n\n\n\n\nResources\n\nggplot2\nggplotly"
  },
  {
    "objectID": "posts/local-llms/index.html",
    "href": "posts/local-llms/index.html",
    "title": "Setting up local LLMs using ollama",
    "section": "",
    "text": "Brief overview\nProjects\nGithub\n(very brief) Quarto/this blog"
  },
  {
    "objectID": "posts/local-llms/index.html#getting-started-in-rstudio",
    "href": "posts/local-llms/index.html#getting-started-in-rstudio",
    "title": "Setting up local LLMs using ollama",
    "section": "",
    "text": "Brief overview\nProjects\nGithub\n(very brief) Quarto/this blog"
  },
  {
    "objectID": "posts/local-llms/index.html#installing-local-llms",
    "href": "posts/local-llms/index.html#installing-local-llms",
    "title": "Setting up local LLMs using ollama",
    "section": "Installing local LLMs",
    "text": "Installing local LLMs\n\n\n\n\n\n\nOllama\nOllama is an open-source framework that allows users to run and manage large language models (LLMs) locally on their machines.\n\nDownload ollama and install (available for Mac, Linux, and Windows).\n\nhttps://ollama.com/\n\nRun ollama for the first time, you will see a llama icon in your menu bar.\nNow you can run your first test with:\nollama run llama3\nThis will download the model llama3 and start an interactive chat session.\nWhen you are done, end chat with \\bye\nYou can download many other models using this terminal command:\n\n\n\n\n\n\n\n\n\nModel\nParameters\nSize\nDownload\n\n\n\n\nLlama 3\n8B\n4.7GB\nollama run llama3\n\n\nLlama 3\n70B\n40GB\nollama run llama3:70b\n\n\nPhi 3 Mini\n3.8B\n2.3GB\nollama run phi3\n\n\nPhi 3 Medium\n14B\n7.9GB\nollama run phi3:medium\n\n\nGemma\n2B\n1.4GB\nollama run gemma:2b\n\n\nGemma\n7B\n4.8GB\nollama run gemma:7b\n\n\nMistral\n7B\n4.1GB\nollama run mistral\n\n\nMoondream 2\n1.4B\n829MB\nollama run moondream\n\n\nNeural Chat\n7B\n4.1GB\nollama run neural-chat\n\n\nStarling\n7B\n4.1GB\nollama run starling-lm\n\n\nCode Llama\n7B\n3.8GB\nollama run codellama\n\n\nLlama 2 Uncensored\n7B\n3.8GB\nollama run llama2-uncensored\n\n\nLLaVA\n7B\n4.5GB\nollama run llava\n\n\nSolar\n10.7B\n6.1GB\nollama run solar\n\n\n\n\n\nNote: You should have at least 8 GB of RAM available to run the 7B models, 16 GB to run the 13B models, and 32 GB to run the 33B models.\n\n\n\nOpen WebUI graphical chat app for ollama models\nIt would be nicer if we had a GUI chat interface to interact with the model and could get code responses in syntax-highlighted code blocks. We can do that and more by installing Open WebUI.\nOpen WebUI can also be used with non-local models like ChatGPT and Github Copilot, but we will focus on local LLMs for this tutorial.\nOpen WebUI: https://github.com/open-webui/open-webui\n\nYou will need to have docker installed. The easiest method is to download and install Docker Desktop from here: https://www.docker.com/products/docker-desktop/\n\nDocker Desktop is free and can be used for commercial use for companies up to 250 employees OR $10 million in yearly revenue.\n\nOnce Docker Desktop is installed, run it. This will enable you to use the docker command from the terminal.\n\nThere are other ways to install docker, you just need to be able to run docker and docker compose commands.\n\nInstall and run Open WebUI with the following command:\ndocker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\nIn a web browser go to http://localhost:3000\n\nOpen WebUI will load\nYou can install additional models from the menu\n\nInstall llama3:instruct, we will need it later.\n\nYou can save conversation chains\nYou can select multiple models and ask a question and it will select the best suited model to answer your question.\n\n(bonus) For anyone running MacOS 13 or higher, open the link in Safari and from the menu bar, choose File &gt; Add to Dock. This will create a standalone webapp.\n\nMore info here: https://support.apple.com/en-us/104996"
  },
  {
    "objectID": "posts/local-llms/index.html#installing-danswer-for-rag-with-ollama-models",
    "href": "posts/local-llms/index.html#installing-danswer-for-rag-with-ollama-models",
    "title": "Setting up local LLMs using ollama",
    "section": "Installing Danswer for RAG with ollama models",
    "text": "Installing Danswer for RAG with ollama models\nRAG stands for Retrieval-Augmented Generation. So far our models can answer questions and are great for giving code examples, but the model cannot access a web page or pull information from local documents. With Danswer, we can allow ollama models to do exactly that.\nDanswer: https://www.danswer.ai/\nDanswer Github: https://github.com/danswer-ai/danswer\nThis install is a little more involved than the last.\n\nGo to the Danswer website (https://www.danswer.ai/) and click “Self-host for Free.”\n\nThis will take you here: https://docs.danswer.dev/quickstart\nWe will follow the instructions on that page (and then make some changes)\n\nClone the Danswer repo:\ngit clone https://github.com/danswer-ai/danswer.git\nNavigate to danswer/deployment/docker_compose\ncd danswer/deployment/docker_compose\nEdit the file danswer/deployment/docker_compose/docker-compose.dev.yml\n\nFind \"3000:80\" and change it to \"3001:80\"\nThis will make the webapp available at http://localhost:3001 since we are already using port 3000 for Open WebUI\n\nTo connect danswer to ollama, create a file called .env in the danswer/deployment/docker_compose directory:\ntouch .env\n\nAdd the following to the file:\n\nGEN_AI_MODEL_PROVIDER=ollama_chat\n# Model of your choice\nGEN_AI_MODEL_VERSION=llama3:instruct\n# Wherever Ollama is running\n# Hint: To point Docker containers to http://localhost:11434, use host.docker.internal instead of localhost\nGEN_AI_API_ENDPOINT=http://host.docker.internal:11434\n\n# Let's also make some changes to accommodate the weaker locally hosted LLM\nQA_TIMEOUT=120  # Set a longer timeout, running models on CPU can be slow\n# Always run search, never skip\nDISABLE_LLM_CHOOSE_SEARCH=True\n# Don't use LLM for reranking, the prompts aren't properly tuned for these models\nDISABLE_LLM_CHUNK_FILTER=True\n# Don't try to rephrase the user query, the prompts aren't properly tuned for these models\nDISABLE_LLM_QUERY_REPHRASE=True\n# Don't use LLM to automatically discover time/source filters\nDISABLE_LLM_FILTER_EXTRACTION=True\n# Uncomment this one if you find that the model is struggling (slow or distracted by too many docs)\n# Use only 1 section from the documents and do not require quotes\nQA_PROMPT_OVERRIDE=weak\n\nIMPORTANT: Add an empty return at the end. The final empty line at the end appears important.\n\nMake sure Docker Desktop is running.\nTo start the application run: (run this from within danswer/deployment/docker_compose)\ndocker compose -f docker-compose.dev.yml -p danswer-stack up -d --pull always --force-recreate\n\nThis step may take a little while to download everything and install.\n\nGo to http://localhost:3001 to load the webapp\n\nYou will need to set up the app before you can start using it:\n\nGo to “Search / Chat with Knowledge” &gt; “Get started”\nSelect the “Custom” tab\nFill in the following values: (none of these are optional even if it say it is)\n\nDisplay Name: ollama\nProvide Name: ollama\nAPI Base: http://host.docker.internal:11434\nModel Names:\n\nllama3:instruct\nllama3:latest\n(you can add more here if you have more installed)\n\nDefault Model: llama3:instruct\n\nClick “Test” to see if all of your settings are correct.\n\nIf it’s successful, you may be good to go\nYou will know for sure once you test running a chat.\n\nClick “Enable”\nClick “Setup your first connector”\n\nYou can add a document or link to include in your search\nDanswer also makes it possible to link popular services like Slack and Google docs\nTry to keep your document/website size small enough. If you try to index all of Google your connector will fail.\n\n\n\nIf things don’t work at first, stop the docker process completely and run this:\ndocker compose -f docker-compose.dev.yml -p danswer-stack up -d --pull always --force-recreate\n\nSometimes this is required to run a few times to make sure the .env file is being used for some reason.\nPotentially restart ollama and docker if that doesn’t work\n\n(bonus) For anyone running MacOS 13 or higher, open the link in Safari and from the menu bar, choose File &gt; Add to Dock. This will create a standalone webapp.\n\nMore info here: https://support.apple.com/en-us/104996"
  },
  {
    "objectID": "posts/local-llms/index.html#code-completion-and-generation-using-continue",
    "href": "posts/local-llms/index.html#code-completion-and-generation-using-continue",
    "title": "Setting up local LLMs using ollama",
    "section": "Code completion and generation using Continue",
    "text": "Code completion and generation using Continue\nI haven’t tested this one yet, but it was on the ollama blog and should work well using the local LLMs installed with ollama. Continue acts as your own AI code assistant within your IDE. It works with VScode and JetBrains for now.\nContinue: https://www.continue.dev/\nVScode extension: https://marketplace.visualstudio.com/items?itemName=Continue.continue\nollama blog post: https://ollama.com/blog/continue-code-assistant"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science Tutorials",
    "section": "",
    "text": "Shiny apps in R\n\n\n\n\n\n\nshiny\n\n\nmodules\n\n\n\n\n\n\n\n\n\nJun 25, 2024\n\n\nSven Nelson\n\n\n\n\n\n\n\n\n\n\n\n\nGetting to know ggplot2\n\n\n\n\n\n\ncode\n\n\nplotting\n\n\n\n\n\n\n\n\n\nJun 11, 2024\n\n\nElizabeth Leshuk\n\n\n\n\n\n\n\n\n\n\n\n\nSetting up local LLMs using ollama\n\n\n\n\n\n\nLLMs\n\n\n\n\n\n\n\n\n\nJun 3, 2024\n\n\nSven Nelson\n\n\n\n\n\n\nNo matching items"
  }
]